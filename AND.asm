global  main						

N equ 10	; ставлю N = 10, т.к. в задаче на вход подаются числа до 2^32 , т.е. может быть десятизначное число


									
							
code_zero equ 48					

section .bss						
var_read:	resb N					
var_write:	resb 5   ; сюда мы будем записывать остаток от 2^16 , а он может быть максимально пятизначным 				
							

section .text						
main:			
	call asm_read	 ; считываем в переменную var_read строку в 10 символов по 1 байту 
	
	xor ebx, ebx  ; отчищаем регистры
	xor rcx, rcx
	xor rax, rax
	
	mov rcx, N  ; в худшем случае придется обработать N символов, rcx - счетчик для loop-a
	
	L1:
	
	mov ebx, 10
	mul ebx        ;умножаем на 10 содержимое регистра rax
	
	xor ebx, ebx
	xor rdx, rdx
	
	mov rdx, 10 ; всего будет 10 кругов loop-a (в худшем случае), мы берем все символы с начала var_read -> нам нужен (10-rcx)ый символ от начала var_read 
	sub rdx, rcx  ; теперь шаг от начала var_read лежит в rdx
	mov bl, [var_read + rdx]   ; ложим этот символ в bl
	cmp bl, 0   			 ; если окажется, что число имеет менее 10-ти разрядов, то в какой-то момент в bl окажется символ конца строки (ASCII код 0) и если это будет так,
					 ; то мы выйдем из цикла
	je L2
	
	sub bl, code_zero       ; если это все таки число, а не конец строки, то превращаем символ в число и прибавляем его к rax 
	add rax, rbx		; на каждом круге цикла предыдущее значение будет умножаться на 10 и прибавляться новый разряд  
	
	loop L1
	
	;теперь в rax лежит число в виде числа (а не строки символов)
	
	L2:     ; нам нужен остаток от деления на 2^16, т.е. содержимое регистра ax
	
	xor ebx, ebx
	mov bx, ax
	xor eax, eax
	mov ax, bx         ;теперь в eax лежит остаток от деления на 2^16, кроме того, это число будет в худшем случае пятизначным и не более того
	
	
	mov rcx, 5 ; нужно преобразовать в строку пятизначное число  
	
	L3:
	xor rdx, rdx
	xor ebx, ebx
	mov bx, 10
	div bx       ; делим на 10 число из rax, остаток от деления (по сути значение младшего разряда) попадет в dx 
	
	add dx, code_zero   ; превращаем цифру в строку
	mov rbx, rcx    ; нужно положить его по адресу, превышающему var_write на rcx-1 шагов
	dec rbx
	mov [var_write + rbx], dl
	loop L3
	
	;по идее после всех этих махинаций по адресу var_write должен лежать 5-ти значный остаток

	call asm_write
	call asm_exit

asm_read:					
	mov rax, 0					; в rax кладем номер системного вызова, кот
	mov rdi, 0					; определяем, откуда надо считать данные 0 это stdin - т.е. считываем из консоли 			; (она же командная строка/терминал, и т.д.)
	mov rsi, var_read				; считает результат посимвольно в строго определенную переменную var_read
	mov rdx, N					; указывает столько байт, сколько нужно считать, тут он должен заполнить весь массив целиком
	syscall						; делает "системный вызов" (это термин, "system call"), т.е. зовет функцию операционной системы 
	ret						; ret нужен, чтобы корректно выйти из wrapper'a.
	
asm_write:						; wrapper - функция, в которую "завернут" стандартный вызов write
	mov rax, 1					; 1 - номер системного вызова write - считывает посимвольно
	mov rdi, 1					; rdi - откуда считываем, 1 это stdout  - т.е. командная строка
	mov rsi, var_write
	mov rdx, 5 				; rdx - кол-во байт, т.е. в консоль будет выведено N байт начиная с адреса var_write
	syscall						; rax, rdi, rsi, rdx - содержат параметры для этого вызова
	ret

asm_exit:						; wrapper - функция, в которую "завернут" стандартный вызов exit
	mov rax, 60					; 60 - номер системного вызова exit - завершить программу
	xor rdi, rdi					; rdi = 0 - код, с которым завершится исполнение программы
	syscall
	ret
